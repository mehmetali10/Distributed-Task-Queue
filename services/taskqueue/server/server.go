package server

import (
	"mid/core/var/common"
	taskqueueservice "mid/services/taskqueue/cmd/service"
	"mid/services/taskqueue/cmd/shared"
	tra "mid/services/taskqueue/cmd/transport"
	_ "mid/services/taskqueue/docs" // docs is generated by Swag CLI, you have to import it.
	"net/http"

	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/metrics/prometheus"
	"github.com/gorilla/mux"
	stdprometheus "github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/rs/cors"
	httpSwagger "github.com/swaggo/http-swagger" // Import the Swagger middleware
)

func CreateRouter(logger log.Logger) *mux.Router {

	allowedOrigins := []string{common.AllowedOrigins}
	allowedHeaders := []string{common.LabelContentType, common.LabelAuthorization}
	allowedMethods := []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete, http.MethodOptions}
	c := cors.New(cors.Options{
		AllowedOrigins:       allowedOrigins,
		AllowedHeaders:       allowedHeaders,
		AllowedMethods:       allowedMethods,
		AllowCredentials:     true,
		OptionsPassthrough:   false,
		OptionsSuccessStatus: http.StatusNoContent,
	})

	fieldKeys := []string{common.LabelMethod, common.LabelError}
	requestCount := prometheus.NewCounterFrom(stdprometheus.CounterOpts{
		Namespace: shared.NameSpaceTaskQueueMicroservice,
		Name:      common.RequestCountName,
		Help:      common.RequestCountHelp,
	}, fieldKeys)

	requestLatency := prometheus.NewSummaryFrom(stdprometheus.SummaryOpts{
		Namespace: shared.NameSpaceTaskQueueMicroservice,
		Name:      common.RequestLatencyName,
		Help:      common.RequestLatencyHelp,
	}, fieldKeys)

	countResult := prometheus.NewSummaryFrom(stdprometheus.SummaryOpts{
		Namespace: shared.NameSpaceTaskQueueMicroservice,
		Name:      common.CountResultName,
		Help:      common.CountResultHelp,
	}, fieldKeys)

	r := mux.NewRouter()

	taskqueueService := taskqueueservice.NewService()
	taskqueueService = &taskqueueservice.LoggingMiddleware{Logger: logger, Next: taskqueueService}
	taskqueueService = &taskqueueservice.InstrumentingMiddleware{RequestCount: requestCount, RequestLatency: requestLatency, CountResult: countResult, Next: taskqueueService}

	r.Methods(http.MethodPost, http.MethodOptions).Path(shared.EnqueueSmsApiPath).Handler(c.Handler(tra.EnqueueSmsServer(taskqueueService)))
	r.Methods(http.MethodPost, http.MethodOptions).Path(shared.TriggerWorkerApiPath).Handler(c.Handler(tra.TriggerWorkerServer(taskqueueService)))
	r.Methods(http.MethodGet, http.MethodOptions).Path(shared.ReadAllSmsQueueApiPath).Handler(c.Handler(tra.ReadAllSmsQueueServer(taskqueueService)))
	r.Methods(http.MethodGet, http.MethodOptions).Path(shared.ReadAllSmsQueueFailedApiPath).Handler(c.Handler(tra.ReadAllSmsQueueFailedServer(taskqueueService)))

	r.Methods(http.MethodGet).Path(shared.Metric).Handler(promhttp.Handler())
	r.PathPrefix(shared.Swagger).Handler(httpSwagger.WrapHandler)
	r.Methods(http.MethodGet, http.MethodOptions).Path(shared.Ping).Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(shared.Pong))
	}))

	return r
}
